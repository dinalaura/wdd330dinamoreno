<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>W07 Notes WDD 330</title>
    <link rel="stylesheet" href="../css/main.css">
</head>

<body>
    <h1>WDD 330: Portfolio</h1>
    <a href="hiking.html"><h2>Team Activity</h2></a>
    <h2>W07 Notes from JavaScript: Novice to Ninja</h2>
    <h3>
        Further Functions
    </h3>
    <p>
        Functions are first-class objects, they can have their own properties and methods,<br>
        as well as accepting other functions as parameters and being returned by other functions.<br>
    </p>
    <h3>Function Properties and Methods</h3>
    <p>
        All functions have a length property that returns the number of parameters the function has.<br>
        Example:<br>
        function square(x) {<br>
        return x*x;<br>
        }<br>
        <br>
        square.length &lt;&lt; 1<br><br>
        Call and Apply Methods<br><br>
        The call() method can be used to set the value of this inside a function to an object <br>
        that is provided as the first argument.<br><br>
        Custom Properties<br>
        You could add a description property to a function that describes what it does:<br>
        <br>
        square.description = 'Squares a number that is provided as<br>
        ➥ an argument'<br>
        &lt;&lt; 'Squares a number that is provided as an argument'<br>
        <br>
        Memoization<br>
        <br>
        A useful feature of this is that it provides result caching, or memoization.<br>
        If a function takes some time to compute a return value, we can save the result in a cache property. <br>
        Then if the same argument is used again later, we can return the value from the cache, <br>
        rather than having to compute the result again.<br>
        <br>
    </p>
    <h3>Immediately Invoked Function Expressions</h3>
    <p>
        An Immediately Invoked Function Expression – or IIFE is an anonymous function <br>
        that is invoked as soon as it’s defined.<br>
        <br>
        (function(){<br>
        const temp = 'World'; <br>
        console.log(`Hello ${temp}`); <br>
        })();<br>
        &lt;&lt; 'Hello World'<br>
        <br>
        IIFEs are a useful way of performing a task while keeping any variables wrapped up <br>
        within the scope of the function.<br>
        <br>
        Temporary Variables<br>
        <br>
        There is no way to remove a variable from a scope once it’s been declared.<br>
        If a variable is only required temporarily, <br>
        it may cause confusion if it’s still available later in the code.<br>
        Placing any code that uses the temporary variable inside an IIFE will ensure <br>
        it’s only available while the IIFE is invoked, then it will disappear.<br>
        <br>
        Example<br>
        let a = 1; <br>
        let b = 2;<br>
        (()=>{<br>
        const temp = a;<br>
        a = b;<br>
        b = temp;<br>
        })();<br>
        a;<br>
        &lt;&lt; 2<br>
        b; <br>
        &lt;&lt;1<br>
        console.log(temp);<br>
        &lt;&lt; Error: "temp is not defined" <br>
        This shows the variable temp does not exist after the function has been invoked.<br>
        <br>
        Initialization Code<br>
        <br>
        An IIFE can be used to set up any initialization code that there’ll be no need for again.<br>
        Much of this can be achieved in ES6 by simply placing the code inside a block. <br>
        This is because variables have block scope when const or let are used, <br>
        whereas in previous versions of JavaScript, only functions maintained the scope of variables.<br>
        <br>
        Safe Use of Strict Mode<br>
        <br>
        One of the problems with simply placing 'use strict' at the beginning of a file is that it will <br>
        enforce strict mode on all the JavaScript in the file, and if you’re using other people’s code, <br>
        there’s no guarantee that they’ve coded in strict mode.<br>
        To avoid this, the recommended way to use strict mode is to place all your code inside an IIFE, like so:<br>
        (function() { <br>
        <br>
        'use strict';<br>
        <br>
        // All your code would go inside this function<br>
        })();<br>
        <br>
        Creating Self-contained Code Blocks<br>
        An IIFE can be used to enclose a block of code inside its own private scope so it doesn’t interfere <br>
        with any other part of the program. Using IIFEs in this way means code can be added or removed separately. <br>
        Example<br>
        Two blocks, A and B, that are able to run code independently of each other:<br>
        <br>
        (function() {<br>
        // block A<br>
        const name = 'Block A'; <br>
        console.log(`Hello from ${name}`);<br>
        }());<br>
        (function() {<br>
        // block B<br>
        const name = 'Block B';<br>
        console.log(`Hello from ${name}`);
        }());<br>
        &lt;&lt; Hello from Block A<br>
        Hello from Block B<br>
        <br>
    </p>
    <h3>Functions that Define and Rewrite Themselves</h3>
    <p>
        The dynamic nature of JavaScript means that a function is able to not only call itself, but define itself, and
        <br>
        even redefine itself. This is done by assigning an anonymous function to a variable that has the same name
        as<br>
        the function.<br>
        Consider the following function:<br>
        function party(){<br>
        console.log('Wow this is amazing!'); <br>
        party = function(){<br>
        console.log('Been there, got the T-Shirt'); <br>
        }<br>
        }<br>
        <br>
        This logs a message in the console, then redefines itself to log a different message in the console.<br>
        <br>
        Init-Time Branching<br>
        <br>
        This technique can be used with the feature detection to create functions that rewrite themselves, known as<br>
        init-time branching. This enables the functions to work more effectively in the browser, and avoid checking
        for<br>
        features every time they’re invoked.<br>
        Recursive Functions<br>
        <br>
        A recursive function is one that invokes itself until a certain condition is met. It’s a useful tool to use
        when<br>
        iterative processes are involved.<br>
    </p>
    <h3>Callbacks</h3>
    <p>
        Callbacks are functions passed to other functions as arguments and then invoked inside the function they are<br>
        passed to.<br>
        <br>
        Event-driven Asynchronous Programming<br>
        <br>
        Callbacks can be used to facilitate event-driven asynchronous programming. JavaScript is a single-threaded<br>
        environment, which means only one piece of code will ever be processed at a time.<br>
        Instead of waiting for an event to occur, a callback can be created that’s invoked when the event happens.
        This<br>
        means that the code is able to run out of order, or asynchronously. Events can be DOM events, such as the
        click<br>
        and keyPress but they can also be events such as the completion of a file download, data returned from a<br>
        database, or the result of a complex operation. <br>
        Here’s an example of a function called wait() that accepts a callback. To simulate an operation that takes
        some<br>
        time to happen, we can use the setTimeout() function to call<br>
        the callback after a given number of seconds: <br>
        <br>
        function wait(message, callback, seconds){ <br>
        setTimeout(callback,seconds * 1000);<br>
        console.log(message);<br>
        }<br>
        <br>
        Callback Hell<br>
        <br>
        The increase in the use of asynchronous programming in JavaScript has meant that more and more callbacks are<br>
        being used. This can result in messy code. This is when more than one callback is used in the same function,<br>
        resulting in a large number of nested blocks that are difficult to comprehend. Callback hell is the term used
        to<br>
        refer to this tangled mess of code.<br>
        <br>
        Promises<br>
        <br>
        A promise represents the future result of an asynchronous operation. Promises don’t do anything that can’t<br>
        already be achieved using callbacks, but they help simplify the process, and avoid the convoluted code that can
        <br>
        result from using multiple callbacks. <br>
        <br>
        The Promise Life Cycle<br>
        When a promise is created, it calls an asynchronous operation and is then said to be pending. It remains in this
        <br>
        state while the operation is taking place. At this stage, the promise is said to be unsettled. Once the <br>
        operation has completed, the promise is said to have been settled. A settled promise can result in two different
        <br>
        outcomes: <br>
        <br>
        Resolved ― the asynchronous operation was completed successfully.<br>
        Rejected ― the asynchronous operation didn’t work as expected, wasn’t <br>
        successfully completed or resulted in an error. <br>
        <br>
        Creating A Promise<br>
        A promise is created using a constructor function. This takes a function called an executor as an argument. <br>
        The executor initializes the promise and starts the asynchronous operation. It also accepts two functions as
        <br>
        arguments: the resolve() function is called if the operation is successful, and the reject() function is called
        <br>
        if the operation fails. The general layout of a promise can be seen in the code below: <br>
        <br>
        const promise = new Promise( (resolve, reject) => { <br>
        // initialization code goes here <br>
        if (success) { <br>
        resolve(value); <br>
        } else { <br>
        reject(error); <br>
        } <br>
        }); <br>
        <br>
        Dealing With A Settled Promise <br>
        <br>
        Once a promise has been settled, the then() method can be used to deal with the outcome. This method accepts two
        <br>
        arguments. The first is a fulfilment function that’s called when the promise is resolved. The second argument is
        <br>
        a rejection function that’s called if the promise is rejected. <br>
        <br>
        Chaining Multiple Promises <br>
        Promises come into their own when multiple asynchronous tasks are required to be carried out one after the <br>
        other. If each function that performs an asynchronous operation returns a promise, we can chain the then() <br>
        methods together to form a sequential piece of code that’s easy to read. <br>
        <br>
        Async Functions<br>
        <br>
        Async functions were added to the ES2017 specification. These functions are preceded by the async keyword and
        <br>
        allow you to write asynchronous code as if it was synchronous. This is achieved by using the await operator <br>
        before an asynchronous function. This will wrap the return value of the function in a promise that can then be
        <br>
        assigned to a variable. The next line of code is not executed until the promise is resolved. <br>
        <br>
        The example below shows how the loadGame() function can be written an async function: <br>
        async function loadGame(userName) { <br>
        try { <br>
        const user = await login(userName); <br>
        const info = await getPlayerInfo (user.id); <br>
        // load the game using the returned info <br>
        } <br>
        catch (error){ <br>
        throw error; <br>
        } <br>
        } <br>
        <br>
        In the example, the loadGame function is preceded by the async keyword, meaning the function will run in an <br>
        asynchronous fashion. <br>
        <br>
        Generalized Functions<br>
        <br>
        Callbacks can be used to build more generalized functions. Instead of having lots of specific functions, one
        <br>
        function can be written that accepts a callback <br>
        <br>
    </p>
    <h3>Functions That Return Functions</h3>
    <p>
        Functions can accept another function as an argument (a callback), but they can also return a function.<br>
        The example below shows a function called returnHello() that returns a “Hello World” message: <br>
        function returnHello() { <br>
        console.log('returnHello() called'); <br>
        return function() { <br>
        console.log('Hello World!'); <br>
        }<br>
        }<br>
        <br>
        Closures<br>
        <br>
        Closures are one of JavaScript’s most powerful features.<br>
        <br>
        Function Scope<br>
        <br>
        The value of a variable was only available inside the block it was created inside if the const or let keywords
        <br>
        were used. This also applies to the body of a function if the var keyword is used. <br>
        <br>
        In the following example, there are two variables: outside, which is available throughout the program, and <br>
        inside, which is only available inside the function: <br>
        const outside = 'In the global scope'; <br>
        function fn() { <br>
        const inside = 'In the function scope'; <br>
        }<br>
        outside <br>
        &lt;&lt; 'In the global scope' <br>
        inside <br>
        &lt;&lt; ReferenceError: inside is not defined <br>
        <br>
        Returning Functions<br>
        <br>
        A closure is formed when the inner function is returned by the outer function, maintaining access to any <br>
        variables declared inside the enclosing function. <br>
        A closure is formed when a function returns another function that then maintains access to any variables created
        <br>
        in the original function’s scope. <br>
        Generators <br>
        ES6 introduced support for generators. These are special functions used to produce iterators that maintain the
        <br>
        state of a value. To define a generator function, an asterisk symbol (*) is placed after the function
        declaration, like so: <br>
        <br>
        function* exampleGenerator() {<br>
        // code for the generator goes here<br>
        }<br>
        <br>
        Calling a generator function doesn’t actually run any of the code in the function; it returns a Generator object
        <br>
        that can be used to create an iterator that implements a next() method that returns a value every time the <br>
        next() method is called. <br>
        <br>
        Generator functions employ the special yield keyword that is used to return a value. The difference between the
        <br>
        yield and the return keywords is that by using yield, the state of the value returned is remembered the next
        <br>
        time yield is called. <br>
        <br>
    </p>
    <h3>Functional Programming</h3>
    <p>
        JavaScript has always supported functional-style programming due to functions being first-class objects. <br>
        The ability to pass functions as arguments, return them from other functions, and use anonymous functions and
        <br>
        closures, are all fundamental elements of functional programming that JavaScript excels at. <br>
        Functional programming is a programming paradigm. Other examples of programming paradigms include object <br>
        oriented programming and procedural programming. JavaScript is a multi-paradigm language, meaning that it can be
        <br>
        used to program in a variety of paradigms. This flexibility is an attractive feature of the language, but it
        <br>
        also makes it harder to adopt a particular coding style as the principles are not enforced by the language. <br>
        <br>
        Pure Functions<br>
        A key aspect of functional programming is its use of pure functions. A pure function is a function that adheres
        <br>
        to the following rules: <br>
        1) The return value of a pure function should only depend on the values provided as arguments. It doesn’t
        rely<br>
        on values from somewhere else in the program.<br>
        2) There are no side-effects. A pure function doesn’t change any values or data elsewhere in the program. It<br>
        only makes non-destructive data transformations and returns new values, rather than altering any of the<br>
        underlying data.<br>
        3) Referential transparency. Given the same arguments, a pure function will always return the same result.<br>
        <br>
        Higher-Order Functions<br>
        <br>
        Higher-order functions are functions that accept another function as an argument, or return another function as
        <br>
        a result, or both.<br>
        Closures are used extensively in higher-order functions as they allow us to create a generic function that can
        <br>
        be used to then return more specific functions based on its arguments. This is done by creating a closure around
        <br>
        a function’s arguments that keeps them “alive” in a return function<br>
        <br>
        Currying <br>
        Currying is a process that involves the partial application of functions. It’s named after the logician Haskell
        <br>
        Curry. His work on a paper by Moses Schönfinkel lead to the development of this programming technique.<br>
        A function is said to be curried when not all arguments have been supplied to the function, so it returns <br>
        another function that retains the arguments already provided, and expects the remaining arguments that were <br>
        omitted when the original function was called. A final result is only returned once all the expected arguments
        <br>
        have eventually been provided.<br>
        <br>
    </p>
    <h3>Quiz Ninja Project</h3>
    <p>
        Use the random() function that we created in this chapter to shake things up a bit. <br>
        Add the random() function near the top of main.js: <br>
        function random(a,b=1) { <br>
        // if only 1 argument is provided, we need to swap the<br>
        ➥ values of a and b if (b === 1) {<br>
        [a,b] = [b,a]; }<br>
        return Math.floor((b-a+1) * Math.random()) + a; }<br>
        <br>
        Create a shuffle() function. This will take an array and change the position of each element. <br>
        <br>
        function shuffle(array) {<br>
        for (let i = array.length; i; i--) {<br>
        let j = random(i)-1;<br>
        [array[i - 1], array[j]] = [array[j], array[i - 1]];<br>
        }<br>
        }<br>
        <br>
        update the game.ask() method with an extra line that invokes the shuffle() function on the game.questions
        array<br>
        before we use the pop() method to select a question. This can be achieved by updating the game.ask() function
        to<br>
        the following:<br>
        <br>
        ask(name){ <br>
        console.log('ask() invoked'); <br>
        if(this.questions.length > 0) { shuffle(this.questions); <br>
        this.question = this.questions.pop(); <br>
        const question = `What is ${this.question.name}'s real ➥ name?`; <br>
        view.render(view.question,question); <br>
        } <br>
        <br>
        <a href="https://codepen.io/daz4126/pen/PjRrGB">CODEPEN</a>
    </p>
    <h3>Ajax</h3>
    <p>
        Ajax is a technique that allows web pages to communicate asynchronously with a server, and it dynamically<br>
        updates web pages without reloading. This enables data to be sent and received in the background, as well as<br>
        portions of a page to be updated in response to user events, while the rest of the program continues to run.<br>
        <br>
        Clients and Servers <br>
        <br>
        The web of computers known as the internet can be separated into two parts: clients and servers. A client, such
        <br>
        as a web browser, will request a resource (usually a web page) from a server, which processes the request and
        <br>
        sends back a response to the client. <br>
        <br>
        A Brief History of Ajax <br>
        When the World Wide Web started, web pages contained static content. Any changes to the content on the page <br>
        required a full page reload, often resulting in the screen going blank while the new page loaded. <br>
        In 1999, Microsoft implemented the XMLHTTP ActiveX control in Internet Explorer 5. It was developed initially
        <br>
        for the Outlook web client, and allowed data to be sent asynchronously in the background using JavaScript. <br>
        <br>
        APIs <br>
        An application programming interface (API) is a collection of methods that allows external access to another<br>
        program or service. Many websites allow controlled access to their data via public APIs<br>
        <br>
        The Fetch API<br>
        The XMLHttpRequest object was finally standardized by the WHATWG and W3C as part of the HTML5 specification,
        <br>
        despite it originally being implemented by Microsoft many years earlier, and already available in most browsers.
        <br>
        It has since been superseded by the Fetch API, which is currently a living standard for requesting and sending
        <br>
        data asynchronously across a network. <br>
        <br>
        Basic Usage <br>
        <br>
        The Fetch API provides a global fetch() method that only has one mandatory argument, which is the URL of the
        <br>
        resource you wish to fetch. A very basic example would look something like the following piece of code: <br>
        <br>
        fetch('https://example.com/data') <br>
        .then( // code that handles the response ) <br>
        .catch( // code that runs if the server returns an error ) <br>
        <br>
        Response Interface <br>
        <br>
        The Fetch API introduced the Response interface that deals with the object that’s returned when the promise is
        <br>
        fulfilled. Response objects have a number of properties and methods that allow us to process the response <br>
        effectively. <br>
        <br>
        Properties of the Response object:<br>
        <br>
        headers – A Headers object containing any headers associated with the response <br>
        url – A string containing the URL of response <br>
        redirected – A boolean value that specifies if the response is the result of a redirect <br>
        type – A string value of “basic”, “cors”, “error” or “opaque”. A value of “basic” is used for a response from
        <br>
        the same domain. <br>
        Redirects <br>
        The redirect() method can be used to redirect to another URL. It creates a new promise that resolves to the <br>
        response from the redirected URL. <br>
        <br>
        Text Responses <br>
        The text() method takes a stream of text from the response, reads it to completion and then returns a promise
        <br>
        that resolves to a USVSting object that can be treated as a string in JavaScript. <br>
        <br>
        File Responses <br>
        The blob() method is used to read a file of raw data, such as an image or a spreadsheet. Once it has read the
        <br>
        whole file, it returns a promise that resolves with a blob object. <br>
        <br>
        JSON Responses <br>
        JSON is probably the most common format for AJAX responses. The json() method is used to deal with these by <br>
        transforming a stream of JSON data into a promise that resolves to a JavaScript object. <br>
        <br>
        Headers Interface <br>
        HTTP headers are used to pass on any additional information about a request or response. Typical information
        <br>
        contained in headers includes the file-type of the resource, cookie information, authentication information and
        <br>
        when the resource was last modified. <br>
        <br>
        FormData <br>
        The Fetch API includes the FormData interface, which makes it much easier to submit information in forms
        using<br>
        Ajax.<br>
        A FormData instance is created using a constructor function: <br>
        <br>
        const data = new FormData(); <br>
        If a form is passed to this constructor function as an argument, the form data instance will serialize all the
        <br>
        data automatically, ready to be sent using Ajax. <br>
        <br>
    </p>
    <h3>Quiz Ninja Project</h3>
    <p>
    Use Ajax to fetch the questions from a server, instead of keeping them in an object inside our JavaScript
    <br>
    file. First of all, we need to remove the array of objects stored in the quiz variable at the start of the main.js
    <br>
    file, and transfer the information into a separate file. <br>
    <br>
    To access this JSON data, use the Fetch API. Add the following code to the top of file:<br>
    <br>
    const url = <br>
    ➥ 'https://spbooks.github.io/jsninja2/questions.json'; <br>
    fetch(url) <br>
    .then(res => res.json()) .then(quiz => { <br>
    view.start.addEventListener('click', () => ➥ game.start(quiz.questions), false); <br>
    view.response.addEventListener('click', (event) => ➥ game.check(event), false); <br>
    }); <br>
    <br> 
    <a href="https://codepen.io/daz4126/pen/LLdKby">CODEPEN</a>
    <br>
    <br>
    <br>
</p>
</body>

</html>