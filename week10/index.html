<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>W10 Notes WDD 330</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
    <h1>WDD 330: Portfolio</h1>
    <h2>W10 Notes from MDN</h2>
  <p><a href="quakeList.html">Earthquake app</a></p>
<h3>
    Client-side form validation </h3>
  <p>
    Before submitting data to the server, it is important to ensure all required form controls are filled out, in the correct format.<br> 
    This is called client-side form validation Client-side validation is an initial check and an important feature of good user experience; <br>
    by catching invalid data on the client-side, the user can fix it straight away. <br>
    <br>
    Your apps should always perform security checks on any form-submitted data on the server-side as well as the client-side, <br>
    because client-side validation is too easy to bypass, so malicious users can still easily send bad data through to your server. <br>
    <br>
    When you enter data, the browser and/or the web server will check to see that the data is in the correct format and within the constraints set by the application.<br>
    Validation done in the browser is called client-side validation, while validation done on the server is called server-side validation. <br>
    <br>
    If the information is correctly formatted, the application allows the data to be submitted to the server and (usually) saved in a database; <br>
    if the information isn't correctly formatted, it gives the user an error message explaining what needs to be corrected. <br>
    <br>
    There are two different types of client-side validation that you'll encounter on the web: <br>
    <br>
    Built-in form validation uses HTML5 form validation features. This validation generally doesn't require much JavaScript. <br>
    Built-in form validation has better performance than JavaScript, but it is not as customizable as JavaScript validation. <br>
    <br>
    JavaScript validation is coded using JavaScript. This validation is completely customizable. <br>
    <br>
     Using built-in form validation required: Specifies whether a form field needs to be filled in before the form can be submitted. <br>
     <br>
        minlength and maxlength: Specifies the minimum and maximum length of textual data (strings) <br>
        <br>
        min and max: Specifies the minimum and maximum values of numerical input types <br>
        <br>
        type: Specifies whether the data needs to be a number, an email address, or some other specific preset type.  <br>
        <br>
        pattern: Specifies a regular expression that defines a pattern the entered data needs to follow. <br>
        <br>
    Example <br>
    
    &lt;form> &lt;label for="choose">Would you prefer a banana or cherry?&lt;/label><br>
        &lt;input id="choose" name="i_like"> &lt;button>Submit&lt;/button> <br>
         &lt;/form> input:invalid { <br>
            border: 2px dashed red; <br>
        }<br> input:valid { <br>
            border: 2px solid black; } <br>
            <br>
    Validating forms using JavaScript <br>
    <br>
    The Constraint Validation API <br>
    <br>
    Most browsers support the Constraint Validation API, which consists of a set of methods and properties available<br>
     on the following form element DOM interfaces: <br>
     <br>
        HTMLButtonElement (represents a &lt;button> element) <br>
            <br>
        HTMLFieldSetElement (represents a &lt;fieldset> element) <br>
            <br>
        HTMLInputElement (represents an &lt;input> element) <br>
        <br>
        HTMLOutputElement (represents an &lt;output> element) <br>
            <br>
        HTMLSelectElement (represents a &lt;select> element) <br>
            <br>
        HTMLTextAreaElement (represents a &lt;textarea> element) <br>
            <br>
</p>
<h3></h3>
<p>
    The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline,<br>
     such as requests and responses. <br>
     <br>
The fetch specification differs from jQuery.ajax() in three main ways: <br>
<br>
The Promise returned from fetch() won’t reject on HTTP error status even if the response is an HTTP 404 or 500. <br>
<br>
fetch() can receive cross-site cookies <br>
<br>
fetch won’t send cookies, unless you set the credentials init option. <br>
<br>
A basic fetch request is really simple to set up. <br>
<br>
fetch('http://example.com/movies.json') .then(response => response.json()) .then(data => console.log(data)); <br>
<br>
Here we are fetching a JSON file across the network and printing it to the console. <br>
The simplest use of fetch() takes one argument — the path to the resource you want to fetch — <br>
and returns a promise containing the response (a Response object). <br>
<br>
The fetch() method can optionally accept a second parameter,<br>
an init object that allows you to control a number of different settings <br>
<br>
Sending a request with credentials included <br>
<br>
To cause browsers to send a request with credentials included, even for a cross-origin call,<br>
 add credentials: 'include' to the init object you pass to the fetch() method. <br>
 <br>
Uploading JSON data <br>
<br>
Use fetch() to POST JSON-encoded data. <br>
<br>
Uploading a file <br>
<br>
Files can be uploaded using an HTML &lt;input type="file" /> input element, FormData() and fetch().<br> 
<br>
Uploading multiple files <br>
<br>
Files can be uploaded using an HTML &lt;input type="file" multiple /> input element, FormData() and fetch(). <br>
<br>
Request() accepts exactly the same parameters as the fetch() method. <br>
You can even pass in an existing request object to create a copy of it: <br>
<br>
const anotherRequest = new Request(myRequest, myInit); <br>
<br>
Guard <br>
<br>
Since headers can be sent in requests and received in responses, <br>
and have various limitations about what information can and should be mutable, headers objects have a guard property.<br>
 This is not exposed to the Web, but it affects which mutation operations are allowed on the headers object. <br>
 <br>
Possible guard values are: <br>
<br>
    none: default. <br>
    <br>
    request: guard for a headers object obtained from a request (Request.headers). <br>
    <br>
    request-no-cors: guard for a headers object obtained from a request created with Request.mode no-cors. <br>
    <br>
    response: guard for a Headers obtained from a response (Response.headers). <br>
    <br>
    immutable: Mostly used for ServiceWorkers; renders a headers object read-only. <br>
    <br>
Feature detection <br>
<br>
Fetch API support can be detected by checking for the existence of Headers, Request, <br>
Response or fetch() on the Window or Worker scope. For example: <br>
<br>
if (window.fetch) { // run my fetch request here } else { // do something with XMLHttpRequest? } <br>
<br>
Polyfill <br>
<br>
To use Fetch in unsupported browsers, there is a Fetch Polyfill available <br>
that recreates the functionality for non-supporting browsers. 
</p>
</body>
</html>